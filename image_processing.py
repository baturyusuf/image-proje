# -*- coding: utf-8 -*-
"""image-processing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mGVZh-uWnimSapfezUu-7TJTvvcr5MTN
"""

# Gerekli kütüphaneleri kur
!pip install Pillow numpy matplotlib

# Gerekli kütüphaneleri içe aktar
import os
import hashlib
import random
import numpy as np
from PIL import Image, ImageDraw, ImageOps
import matplotlib.pyplot as plt
from google.colab import files
import io

# Büyük görüntü dosyalarıyla çalışırken PIL limitini kaldır
Image.MAX_IMAGE_PIXELS = None

print("Kütüphaneler kuruldu ve içe aktarıldı.")

# --- Proje Parametreleri ---

# Blok boyutu. SHA-256 (256 bit) için 16x16 (256 piksel) idealdir.
# Her pikselin 1 LSB'si 1 bit hash saklayacaktır.
BLOCK_SIZE = 16

#@title Lütfen Gizli Anahtarınızı (Secret Key) Girin
#@markdown Bu anahtar, mühürleme ve doğrulama için kullanılacaktır.
SECRET_KEY = "varsayilan-anahtar-123" #@param {type:"string"}

if SECRET_KEY == "varsayilan-anahtar-123-bunu-degistirin" or len(SECRET_KEY) < 10:
    print("UYARI: Lütfen daha güvenli ve uzun bir 'SECRET_KEY' girin.")
else:
    print(f"Gizli Anahtar ayarlandı: {SECRET_KEY[:4]}...{SECRET_KEY[-4:]}")

print(f"Blok Boyutu: {BLOCK_SIZE}x{BLOCK_SIZE} olarak ayarlandı.")

def bytes_to_bits(data_bytes):
    """SHA-256 çıktısı olan 32 byte'ı 256 bitlik bir listeye (0/1) çevirir."""
    bits = []
    for byte in data_bytes:
        for i in range(8):
            bit = (byte >> (7 - i)) & 1
            bits.append(bit)
    return bits

def bits_to_bytes(bits_list):
    """256 bitlik bir listeyi (0/1) 32 byte'lık bir byte dizisine geri çevirir."""
    if len(bits_list) % 8 != 0:
        raise ValueError("Bit listesinin uzunluğu 8'in katı olmalıdır.")

    data_bytes = bytearray()
    for i in range(0, len(bits_list), 8):
        byte_bits = bits_list[i:i+8]
        byte_val = 0
        for bit in byte_bits:
            byte_val = (byte_val << 1) | bit
        data_bytes.append(byte_val)
    return bytes(data_bytes)

def create_block_mapping(num_blocks, key):
    """
    Gizli anahtara dayalı olarak deterministik (tekrarlanabilir) bir
    blok eşleştirme haritası oluşturur.
    """
    indices = list(range(num_blocks))
    rng = random.Random(key)
    rng.shuffle(indices)
    return indices

def preprocess_image(pil_image, block_size):
    """Görüntüyü grayscale'e çevirir ve boyutlarını bloklara tam bölünecek şekilde kırpar."""
    # Grayscale ('L') moda çevir (1 kanal, 8 bit)
    img = pil_image.convert('L')

    # Boyutları kırp
    width, height = img.size
    width = (width // block_size) * block_size
    height = (height // block_size) * block_size
    img = img.crop((0, 0, width, height))

    return img

print("Yardımcı fonksiyonlar tanımlandı.")

def embed_watermark_logic(original_pil_image, key, block_size):
    """
    Bir PIL Görüntü nesnesini alır, mühürler ve mühürlenmiş PIL Görüntü nesnesini döndürür.
    """
    print(f"Faz 1: Mühürleme Başlatıldı...")

    img = preprocess_image(original_pil_image, block_size)
    width, height = img.size
    img_array = np.array(img, dtype=np.uint8)

    num_blocks_x = width // block_size
    num_blocks_y = height // block_size
    num_blocks_total = num_blocks_x * num_blocks_y

    print(f"Görüntü {width}x{height} boyutunda işleniyor. Toplam blok: {num_blocks_total}")

    # 1. Adım: Tüm blokların Mühür (Hash) Listesini Oluştur
    hash_list = []
    print("Adım 1/3: Mühürler (hash'ler) hesaplanıyor...")
    for i in range(num_blocks_total):
        by = (i // num_blocks_x) * block_size
        bx = (i % num_blocks_x) * block_size
        block_data = img_array[by:by+block_size, bx:bx+block_size]
        msb_data = (block_data & 0xFE).astype(np.uint8)

        msb_bytes = bytes(msb_data.flatten())
        hash_input = msb_bytes + key.encode('utf-8')
        block_hash = hashlib.sha256(hash_input).digest()
        hash_list.append(block_hash)

    # 2. Adım: Blok Eşleştirme Haritasını Oluştur
    print("Adım 2/3: Blok eşleştirme haritası oluşturuluyor...")
    mapping = create_block_mapping(num_blocks_total, key)

    # 3. Adım: Mühürleri Görüntüye Göm
    print("Adım 3/3: Mühürler LSB katmanına gömülüyor...")
    watermarked_array = np.copy(img_array)

    for i in range(num_blocks_total):
        hash_to_embed = hash_list[i]
        hash_bits = bytes_to_bits(hash_to_embed)
        j = mapping[i]

        by = (j // num_blocks_x) * block_size
        bx = (j % num_blocks_x) * block_size

        target_block = watermarked_array[by:by+block_size, bx:bx+block_size]
        target_pixels_flat = target_block.flatten()

        for p_idx in range(block_size * block_size):
            pixel_val = target_pixels_flat[p_idx]
            bit_to_embed = hash_bits[p_idx]
            new_pixel_val = (pixel_val & 0xFE) | bit_to_embed
            target_pixels_flat[p_idx] = new_pixel_val

        watermarked_array[by:by+block_size, bx:bx+block_size] = target_pixels_flat.reshape((block_size, block_size))

    watermarked_img = Image.fromarray(watermarked_array, 'L')
    print(f"FAZ 1 TAMAMLANDI: Mühürlenmiş görüntü hafızada oluşturuldu.")
    return watermarked_img

def verify_watermark_logic(image_to_check_pil, key, block_size):
    """
    Şüpheli bir PIL Görüntü nesnesini alır, doğrular ve (sahtecilik_haritası, bozuk_blok_sayısı) döndürür.
    """
    print(f"Faz 2: Doğrulama Başlatıldı...")

    img = preprocess_image(image_to_check_pil, block_size)
    width, height = img.size
    img_array = np.array(img, dtype=np.uint8)

    num_blocks_x = width // block_size
    num_blocks_y = height // block_size
    num_blocks_total = num_blocks_x * num_blocks_y

    print(f"Şüpheli görüntü {width}x{height} boyutunda işleniyor. Toplam blok: {num_blocks_total}")

    # Sonuç haritasını (RGB) oluştur
    tamper_map_array = np.zeros((height, width, 3), dtype=np.uint8)

    # 1. Adım: Eşleştirme Haritasını Yeniden Oluştur
    print("Adım 1/2: Blok eşleştirme haritası yeniden oluşturuluyor...")
    mapping = create_block_mapping(num_blocks_total, key)

    tampered_blocks = 0

    # 2. Adım: Tüm Blokları Doğrula
    print("Adım 2/2: Mühürler kontrol ediliyor...")
    for i in range(num_blocks_total):
        by_i = (i // num_blocks_x) * block_size
        bx_i = (i % num_blocks_x) * block_size

        # --- A: Gömülü Mührü Oku ---
        j = mapping[i]
        by_j = (j // num_blocks_x) * block_size
        bx_j = (j % num_blocks_x) * block_size

        target_block = img_array[by_j:by_j+block_size, bx_j:bx_j+block_size]
        target_pixels_flat = target_block.flatten()

        embedded_bits = []
        for p_idx in range(block_size * block_size):
            lsb_bit = target_pixels_flat[p_idx] & 1
            embedded_bits.append(lsb_bit)

        H_i_embedded = bits_to_bytes(embedded_bits)

        # --- B: Mevcut İçeriğin Mührünü Hesapla ---
        block_data_i = img_array[by_i:by_i+block_size, bx_i:bx_i+block_size]
        msb_data_i = (block_data_i & 0xFE).astype(np.uint8)

        msb_bytes_i = bytes(msb_data_i.flatten())
        hash_input_i = msb_bytes_i + key.encode('utf-8')
        H_i_current = hashlib.sha256(hash_input_i).digest()

        # --- C: Karşılaştır ---
        if H_i_embedded != H_i_current:
            tampered_blocks += 1
            # Sahtecilik haritasında bu bloğu kırmızıya boya
            tamper_map_array[by_i:by_i+block_size, bx_i:bx_i+block_size, 0] = 255

    tamper_map_img = Image.fromarray(tamper_map_array, 'RGB')

    print(f"FAZ 2 TAMAMLANDI: Doğrulama bitti.")
    return tamper_map_img, tampered_blocks

print("Ana mantık fonksiyonları (embed_watermark_logic, verify_watermark_logic) tanımlandı.")

print("--- BÖLÜM 1: GÖRÜNTÜ MÜHÜRLEME ---")
print(f"Kullanılacak Gizli Anahtar: {SECRET_KEY[:4]}...{SECRET_KEY[-4:]}\n")
print("Lütfen mühürlemek istediğiniz ORİJİNAL görüntüyü yükleyin:")

# 1. Dosya Yükleme
uploaded = files.upload()

if len(uploaded) == 0:
    print("\nİşlem iptal edildi. Dosya yüklenmedi.")
else:
    # 2. Görüntüyü Hafızaya Yükleme
    filename = list(uploaded.keys())[0]
    original_image = Image.open(io.BytesIO(uploaded[filename]))

    # 3. Mühürleme İşlemini Çağırma
    # (Hücre 2'deki SECRET_KEY ve BLOCK_SIZE değerlerini kullanır)
    watermarked_image = embed_watermark_logic(original_image, SECRET_KEY, BLOCK_SIZE)

    # 4. Sonuçları Gösterme
    # Görüntüleri matplotlib ile göstermek için ön işleme
    display_orig = preprocess_image(original_image, BLOCK_SIZE)

    fig, axes = plt.subplots(1, 2, figsize=(14, 7))
    axes[0].imshow(display_orig, cmap='gray')
    axes[0].set_title(f"Orijinal Görüntü (İşlenmiş)\n{filename}")
    axes[0].axis('off')

    axes[1].imshow(watermarked_image, cmap='gray')
    axes[1].set_title("Mühürlenmiş Görüntü (Görsel Fark Yok)")
    axes[1].axis('off')

    plt.tight_layout()
    plt.show()

    # 5. Mühürlenmiş Görüntüyü Kaydetme ve İndirme Linki
    watermarked_filename = "muhurlenmis_" + os.path.splitext(filename)[0] + ".png"
    # Kayıpsız PNG olarak kaydet
    watermarked_image.save(watermarked_filename, "PNG")

    print(f"\n'{watermarked_filename}' başarıyla oluşturuldu.")
    print("Mühürlenmiş görüntüyü indirmek için aşağıdaki linki kullanabilirsiniz:")
    files.download(watermarked_filename)

print("--- BÖLÜM 2: GÖRÜNTÜ DOĞRULAMA ---")
print(f"Kullanılacak Gizli Anahtar: {SECRET_KEY[:4]}...{SECRET_KEY[-4:]}\n")
print("Lütfen bütünlüğünü kontrol etmek istediğiniz ŞÜPHELİ görüntüyü yükleyin:")

# 1. Dosya Yükleme
uploaded_check = files.upload()

if len(uploaded_check) == 0:
    print("\nİşlem iptal edildi. Dosya yüklenmedi.")
else:
    # 2. Görüntüyü Hafızaya Yükleme
    check_filename = list(uploaded_check.keys())[0]
    image_to_check = Image.open(io.BytesIO(uploaded_check[check_filename]))

    # 3. Doğrulama İşlemini Çağırma
    tamper_map, tampered_block_count = verify_watermark_logic(image_to_check, SECRET_KEY, BLOCK_SIZE)

    # 4. Sonuçları Yorumlama ve Gösterme
    print("\n--- DOĞRULAMA SONUCU ---")
    if tampered_block_count == 0:
        print(f"SONUÇ: Görüntü Bütünlüğü DOĞRULANDI.")
        print("Görüntü orijinal ve üzerinde oynama yapılmamış.")
    else:
        print(f"SONUÇ: Görüntü Bütünlüğü BOZULMUŞ!")
        print(f"Toplam {tampered_block_count} blokta değişiklik tespit edildi.")
    print("--------------------------")

    # Görüntüleri matplotlib ile göstermek için ön işleme
    display_check = preprocess_image(image_to_check, BLOCK_SIZE)

    # Haritayı orijinal görüntüyle birleştir (daha net görmek için)
    display_check_rgb = display_check.convert("RGB")
    overlay_map = Image.blend(display_check_rgb, tamper_map, alpha=0.4)

    fig, axes = plt.subplots(1, 3, figsize=(21, 7))

    axes[0].imshow(display_check, cmap='gray')
    axes[0].set_title(f"Kontrol Edilen Görüntü\n{check_filename}")
    axes[0].axis('off')

    axes[1].imshow(tamper_map)
    axes[1].set_title("Sahtecilik Haritası (Kırmızı = Bozuk)")
    axes[1].axis('off')

    axes[2].imshow(overlay_map)
    axes[2].set_title("Harita ve Görüntü (Üst Üste)")
    axes[2].axis('off')

    plt.tight_layout()
    plt.show()

    # 5. Sahtecilik Haritasını Kaydetme ve İndirme Linki
    map_filename = "SAHTECILIK_HARITASI_" + os.path.splitext(check_filename)[0] + ".png"
    tamper_map.save(map_filename, "PNG")

    print(f"\n'{map_filename}' başarıyla oluşturuldu.")
    print("Sahtecilik haritasını indirmek için aşağıdaki linki kullanabilirsiniz:")
    files.download(map_filename)